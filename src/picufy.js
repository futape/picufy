/*! Picufy 1.0.0 | Copyright (c) 2015 Lucas Krause | New BSD License | http://picufy.futape.de */

(function(window){



    var document=window.document,
        self,
        proto;
    
    
    
    //#Picufy()#
    /**
     * void Picufy( string text [, int size ] )
     *
     * The constructor of a Picufy object.
     * For more information, see [`init()`](#).
     */
    self=function(str_text, int_size){
        this.init.apply(this, arguments);
    };
    
    
    
    window.Picufy=self;
    
    proto=self.prototype;
    
    
    
    //#static-functions#
    
    //#Picufy.eqArray()#
    /**
     * bool eqArray( array array1, array array2 )
     *
     * Checks whether two array are identical by comparing their items using a strict comparision (`===`).
     * If the number of the arrays' items differ or if a comparision returns `false`, `false` is returned. If everything matches, `true` is returned.
     *
     * Returns whether the arrays are equal to each other.
     */
    self.eqArray=function(arr_a, arr_b){
        if(arr_a.length!=arr_b.length){
            return false;
        }
        
        for(var i=0; i<arr_a.length; i++){
            if(arr_a[i]!==arr_b[i]){
                return false;
            }
        }
        
        return true;
    };
    
    //#Picufy.rgb2hsl()#
    /**
     * int[] rgb2hsl( int[] rgb )
     *
     * Converts a RGB color value to HSL.
     * The function is a slighly modified version of Michael Jackson's [RGB to HSL conversion algorithm](https://github.com/mjackson/mjijackson.github.com/blob/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.txt).
     *
     * +   `rgb`: An array containing the RGB color value to convert. The array is expected to be of the form `[R, G, B]`.
     *
     * Returns the generated HSL color value as an array of the form `[H, S, L]`.
     */
    self.rgb2hsl=function(arr_rgb){
        var int_r=arr_rgb[0], //0...255
            int_g=arr_rgb[1],
            int_b=arr_rgb[2],
            
            num_r=int_r/255, //0.0...1.0
            num_g=int_g/255,
            num_b=int_b/255,
            
            num_max=Math.max(num_r, num_g, num_b),
            num_min=Math.min(num_r, num_g, num_b),
            num_diff=num_max-num_min,
            num_sum=num_max+num_min,
            
            num_h, //0.0...1.0
            num_s,
            num_l=num_sum/2;

        if(num_diff==0){ //achromatic
            num_h=0;
            num_s=0;
        }else{
            /**/
            num_s=num_diff/(num_l>0.5 ? 2-num_sum : num_sum); //or `num_diff/Math.abs((num_l>0.5 ? 2 : 0)-num_sum)`
            /*/
            num_s=num_diff/(1-Math.abs(2*num_l-1))`
            /**/
            
            var int_hAdd;
            
            if(num_r==num_max){
                num_h=num_g-num_b;
                int_hAdd=num_h<0 ? 6 : 0;
            }else if(num_g==num_max){
                num_h=num_b-num_r;
                int_hAdd=2;
            }else if(num_b==num_max){
                num_h=num_r-num_g;
                int_hAdd=4;
            }
            
            num_h/=num_diff;
            num_h+=int_hAdd;
            num_h/=6;
        }
        
        var int_h=Math.round(num_h*360), //0...360
            int_s=Math.round(num_h*100), //0...100
            int_l=Math.round(num_l*100),
            arr_hsl=[int_h, int_s, int_l];

        return arr_hsl;
    }
    
    
    
    //#static-picufy-properties#
    
    //#Picufy.config#
    /**
     * object config
     *
     * An object containig the Picufy configuration options.
     * The following options are available.
     *
     * +   `int canvasSize = 200`: The default size of the created canvas used as default value for the Picufy constructor's second parameter.
     */
    self.config={
        "canvasSize":200
    };


    
    //#static-picufy-functions#
    
    //#Picufy.encode()#
    /**
     * Picufy encode(string text [, int size ])
     *
     * This function is identical to `new Picufy(text, size)`.
     * For more information, see [`Picufy()`](#).
     */
    self.encode=function(str_text, int_size){
        return new self(str_text, int_size);
    };
    
    //#Picufy.decode()#
    /**
     * Picufy decode( HTMLCanvasElement canvas )
     *
     * Decodes a canvas generated by Picufy and creates a new Picufy object from the information retrieved from the canvas.
     * When decoding an image file (e.g. a `.png` file), a new `HTMLCanvasElement` object must be created and that image must be drawn to it. When doing so, it's important, that the canvas has the exact same dimensions as the image and that the image is not scaled down or up when drawing it to the canvas.
     *
     * +   `canvas`: The canvas to decode. The image must comply with the [Picufy specification](#) that is also follow by Picufy when *creating* a canvas.
     */
    self.decode=function(el_canvas){ //`el_canvas` must fulfill all requirements followed when creating a canvas from a text using Picufy
        var int_size=el_canvas.width,
            ctx_a=el_canvas.getContext("2d"),
            
            imgd_a=ctx_a.getImageData(0, int_size-1, int_size, 1),
            arr_px=Array.prototype.slice.call(imgd_a.data),

            arr_rgb=null,
            int_sqSize=null;
        
        for(var i=arr_px.length-4; i>=0; i-=4){
            var arr_rgb_b=arr_px.slice(i, i+3);
            
            if(arr_rgb==null){
                arr_rgb=arr_rgb_b;
            }else if(!self.eqArray(arr_rgb_b, arr_rgb)){
                int_sqSize=(arr_px.length-i)/4-1;
                
                break;
            }
        }
        
        if(int_sqSize==null){
            int_sqSize=int_size;
        }
        
        var int_side=int_size/int_sqSize, //always evenly dividable
            arr_baseHsl=self.rgb2hsl(arr_rgb),
            map_pic={ //properties
                "canvas":el_canvas,
                "size":int_size,
                "greyscale":arr_baseHsl[1]==0
            },
            
            arr_matrix=[];
        
        for(var i=0; i<int_side; i++){
            var arr_row=[];
            
            for(var u=0; u<int_side; u++){
                imgd_a=ctx_a.getImageData(u*int_sqSize, i*int_sqSize, 1, 1);
                arr_px=Array.prototype.slice.call(imgd_a.data);
                
                var arr_hsl=self.rgb2hsl(arr_px.slice(0, 3)); //or `arr_col`
                
                arr_row.push(arr_hsl);
            }
            
            arr_matrix.push(arr_row);
        }
        
        map_pic.matrix=arr_matrix;
        
        var str_text="",
            str_charBin="";
        
        for(var i=0; i<arr_matrix.length; i++){
            var arr_row=arr_matrix[i];
            
            for(var u=0; u<arr_row.length; u++){
                var arr_hsl=arr_row[u], //or `arr_col`
                    int_h=arr_hsl[0],
                    int_s=arr_hsl[1],
                    int_l=arr_hsl[2];
                
                if(int_h>arr_baseHsl[0]+30){
                    int_h-=360;
                }
                
                var int_vary=map_pic.greyscale ? int_l : int_h, //or `int_factor`
                    int_base=arr_baseHsl[map_pic.greyscale ? 2 : 0]; //`arr_baseHsl[2]` will always be 50; `arr_baseHsl[0]` will always be evenly dividable by 60
                
                if(int_vary==int_base){ //character bit sequence termination
                    if(str_charBin!=""){
                        var str_char=String.fromCharCode(parseInt(str_charBin, 2));
                        
                        str_text+=str_char;
                        
                        str_charBin="";
                    }
                }else{
                    str_charBin+=int_vary<int_base ? "0" : "1";
                }
            }
        }
        
        var pic_a=new self(str_text); //! set second param to 1 (or 0; however, 1 is min. value) ?
        
        for(var key in map_pic){
            pic_a[key]=map_pic[key];
        }
        
        return pic_a;
    };
    
    
    
    //#properties#
    
    //#Picufy.text#
    /**
     * string text
     *
     * The text represented by the image.
     * See [`Picufy()`](#) for more information.
     */
    proto.text;
    
    //#Picufy.greyscale#
    /**
     * bool greyscale
     *
     * Whether the image consists of shades of grey only.
     * This happens when the first character of the encoded text is outside of the range `a-zA-Z`.
     * See [`initColor()`](#) for more information.
     */
    proto.greyscale;
    
    //#Picufy.baseHue#
    /**
     * int baseHue
     *
     * The base hue value upon which the squares' colors' hue values are calculated.
     * Always `0` for greyscaled images.
     * See [`initColor()`](#) for more information.
     */
    proto.baseHue;
    
    //#Picufy.matrix#
    /**
     * int[][] matrix
     *
     * A two-dimensional array containing the HSL color values for the squares in its second level and the *rows* of the image in its root level.
     * See [`initMatrix()`](#) for more information.
     */
    proto.matrix;
    
    //#Picufy.size#
    /**
     * int size
     *
     * The width and height of the created canvas. If this property's value can't be divided by the number of squares per row evenly, the value is increased.
     * For more information see [`initMatrix()`](#) and [`Picufy()`](#).
     */
    proto.size;
    
    //#Picufy.canvas#
    /**
     * HTMLCanvasElement canvas
     *
     * The generated canvas representing the encoded text.
     * See [`initCanvas()`](#) for more information.
     */
    proto.canvas;
    
    
    
    //#init-functions#
    
    //#Picufy.init()#
    /**
     * void init( string text [, int size ] )
     *
     * Initializes the objects properties.
     *
     * +   `text`: The text to encode as an image. Should not be empty.
     * +   `size`: The size of the generated canvas. If not specified, `Picufy.config.canvasSize` is used instead.
     *             Must be greater than 0, otherwise 1 is used instead.
     */
    proto.init=function(str_text, int_size){
        int_size=int_size==null ? self.config.canvasSize : int_size;
        
        this.text=str_text;
        this.size=Math.max(int_size, 1);
        
        this.initColor(); //init `baseHue` and `greyscale`
        this.initMatrix(); //init `matrix` and adjusts `size` if necessary
        this.initCanvas(); //init `canvas`
    };
    
    //#Picufy.initColor()#
    /**
     * void initColor()
     *
     * Initializes the `greyscale` and `baseHue` properties.
     * The `baseHue` is determined upon the lowercased, first character of the text. For "a" `baseHue` will be 0, for "b" it will be 60, for "c": 120, "d": 180, "e": 240, "f": 300, and for "g": 0 again, and so on for letters from "h" to "z".
     * Characters outside of the range of `a-zA-Z` will produce a `baseHue` of 0 and will set `greyscale` to `true`, otherwise it would be `false`.
     */
    proto.initColor=function(){
        var int_first=this.text.substr(0, 1).toLowerCase().charCodeAt(0);
        
        this.greyscale=(isNaN(int_first) || int_first<97 || int_first>122);
        this.baseHue=this.greyscale ? 0 : ((int_first-97)*60)%360;
    }
    
    //#Picufy.initMatrix()#
    /**
     * void initMatrix()
     *
     * Initializes the `matrix` property.
     * The value for that property will be a two-dimensional array containing the HSL color values as arrays at the second level and the *rows* of the produced image at the root level.
     * The number of rows and the number of color values in a row is equal to the square root of all squares in the produced image. Therefore the overall number of items in this array is equal to the number of all squares.
     * Each square represents one bit or a *bit sequence termination* marking the end of a sequence of bits making up one character.
     * Whether a square marks up a 0 or a 1 bit, is controlled by its color's hue value. If it's lower than the `baseHue`, it's a 0 bit, if it's greater than `baseHue`, it's a 1 bit. Squares with a hue value equal to the `baseHue` mark a bit sequence termination.
     * For greyscale images the lightness value is used instead of the hue value. If the lower than 50, a 0 bit is assumed, if it's greater than 50, it's a 1 bit, and if the lightness value is equal to 50, the square marks a bit sequnce termiation. The hue value for such images is always 0.
     * Also, for greyscale images the saturation is always set to 0, while it's a value between 50 and 100 for colored images.
     * For colored images, the hue value is always in the range of `baseHue - 30` to `baseHue + 30`, and the lightness value is a number between 25 and 75.
     * Except for the direction (+ or -) of the difference between the `baseHue` ad the hue value of a square for a colored image, or between the lightness of a square and 50 for greyscale images, everything else is randomly picked inside of the specified ranges.
     * If the number of squares isn't a square number, the next higher one is used instead and bit sequence terminators are used to add the missing squares in randomly picket places.
     * The bottom right square is always a bit sequence terminator and is called *base square* since it always represents the base color, upon which the other squares' colors are calculated. the square to its left (if any) will never be a bit sequence terminator, too, and will therfore never have the same color.
     * Also increases the `size` property if it's no evenly dividable by the number of squares per row, so that each square consists of *full pixels* only.
     */
    proto.initMatrix=function(){
        var arr_bin=[]; //(1|0|-1)[]
        
        for(var i=0; i<this.text.length; i++){
            var int_char=this.text.charCodeAt(i),
                str_charBin=int_char.toString(2),
                arr_charBin=[]; //(0|1)[]
            
            for(var u=0; u<str_charBin.length; u++){
                arr_charBin.push(parseInt(str_charBin.substr(u, 1)));
            }
            
            arr_bin.push(arr_charBin, -1);
        }
        
        var int_len=Array.prototype.concat.apply([], arr_bin).length,
            int_side=Math.ceil(Math.sqrt(int_len)),
            int_num=Math.pow(int_side, 2),
            int_pad=int_num-int_len;
        
        for(var i=0; i<int_pad; i++){
            arr_bin.splice(Math.round(Math.random()*(arr_bin.length-2)), 0, -1); //`arr_bin.length-2`: the square to the left of the bottom right square (base square) must not be a base square. distribute the remaining base squares (`int_pad`) between the peceding ones
        }
        
        arr_bin=Array.prototype.concat.apply([], arr_bin);
        
        var arr_matrix=[];
        
        for(var i=0; i<int_side; i++){
            var arr_row=[];
            
            for(var u=0; u<int_side; u++){
                var int_bin=arr_bin[i*int_side+u],
                    arr_hsl, //or `arr_col`
                    
                    int_h=this.baseHue,
                    int_s,
                    int_l;
                
                if(this.greyscale){
                    int_s=0;
                    int_l=50;
                    
                    if(int_bin!=-1){
                        int_l+=(1+Math.round(Math.random()*24))*(int_bin==0 ? -1 : 1);
                    }
                }else{
                    if(int_bin!=-1){
                        int_h+=360;
                        int_h+=(1+Math.round(Math.random()*29))*(int_bin==0 ? -1 : 1);
                        int_h%=360;
                    }
                    
                    int_s=50+Math.round(Math.random()*50);
                    int_l=25+Math.round(Math.random()*50);
                }
                
                arr_hsl=[int_h, int_s, int_l]; 
                
                arr_row.push(arr_hsl);
            }
            
            arr_matrix.push(arr_row);
        }
        
        this.matrix=arr_matrix;
        
        this.size=Math.ceil(this.size/int_side)*int_side; //no "half pixels"
    }
    
    //#Picufy.initCanvas()#
    /**
     * void initCanvas()
     *
     * Initializes the `canvas` property.
     * Draws the sqares described by the `matrix` property to a `<canvas>` element. The `width` and `height` attributes of the canvas are set to the value of the `size` property.
     */
    proto.initCanvas=function(){
        var el_canvas=document.createElement("canvas");
        
        el_canvas.setAttribute("width", this.size);
        el_canvas.setAttribute("height", this.size);
        
        var ctx_a=el_canvas.getContext("2d"),
            int_side=this.matrix.length,
            int_sqSize=this.size/int_side; //always full number (integer), since the factors are evenly dividable (managed in `initMatrix`)
        
        for(var i=0; i<int_side; i++){
            for(var u=0; u<int_side; u++){
                var arr_hsl=this.matrix[i][u];
                
                ctx_a.fillStyle="hsl("+arr_hsl[0]+", "+arr_hsl[1]+"%, "+arr_hsl[2]+"%)";
                ctx_a.fillRect(u*int_sqSize, i*int_sqSize, int_sqSize, int_sqSize);
            }
        }
        
        this.canvas=el_canvas;
    }
    
    
    
    //#getter-functions#
    
    //#Picufy.toString()#
    /**
     * string toString()
     *
     * This function is automatically called when a Picufy object is converted to a string (e.g. when concatenating it with a string).
     *
     * Returns the value of the `text` property.
     */
    proto.toString=function(){
        return this.text;
    }
    
    
    
})(window);
